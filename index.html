<!doctype html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <meta property="og:image"
          content="https://raw.communitydragon.org/latest/game/assets/ux/tft/stageicons/announce_icon_planning.png">
    <meta property="og:title" content="TFT Cheat Sheet">
    <meta property="og:site_name" content="TFT Cheat Sheet">
    <meta property="og:type" content="website">
    <meta property="og:description" content="TFT Cheat Sheet with Match History (beta)">
    <meta property="og:url" content="https://lucube.github.io/">

    <title>TFT Cheat Sheet</title>
    <link rel="icon"
          href="https://raw.communitydragon.org/latest/game/assets/ux/tft/stageicons/announce_icon_planning.png"/>

    <style>
        * {
            padding: 0;
            margin: 0;
            text-align: center;
            font-family: Arial, sans-serif;
            font-size: 0;
            color: white;
        }

        body {
            background: rgb(29, 29, 31);
            display: flex;
            flex-wrap: wrap;
            flex-direction: column;
            height: 633px;
            justify-content: flex-end;
            overflow-x: hidden;
        }

        #credits {
            width: 600px;
            height: 200px;
            background-color: orange;
            color: black;
            font-size: 22px;
            padding: 20px;
            border: 2px yellow solid;
            border-radius: 25px;
        }

        table, th, td {
            border: 3px solid black;
            border-collapse: collapse;
        }

        th {
            font-size: 8px;
        }

        #navbar {
            visibility: hidden;
        }

        .itemtable {
            align-self: flex-end;
            visibility: hidden;
        }

        .championtable {
            align-self: flex-start;
            visibility: hidden;
        }

        .txt {
            font-size: 16px;
        }

        img {
            width: 36px;
        }

        #navbar ul {
            list-style-type: none;
            margin: 0;
            padding: 0;
        }

        .menuitem {
            font-size: 15px;
            font-weight: bold;
            text-decoration: none;
            color: #fff;
            padding: 12px 12px;
            margin: 6px;
            border-radius: 20px;
            background-color: rgb(63, 63, 65);
            display: block;
            overflow: hidden;
            width: 120px;
            float: right;
        }

        .menuitem:hover {
            background-color: rgb(95, 95, 97);
        }

        .halfcell {
            width: 18px;
            height: 36px;
            overflow: hidden;
            display: inline-block;
        }

        .halfcellimg {
            width: 36px;
            height: 36px;
            margin: 0 -9px;
        }

        .thirdcell {
            width: 12px;
            height: 36px;
            overflow: hidden;
            display: inline-block;
        }

        .thirdcellimg {
            width: 36px;
            height: 36px;
            margin: 0 -9px;
        }

        .itemtable tr th img {
            width: 48px;
        }

        .championtable tr th img {
            width: 32px;
        }

        .championtable tr:nth-child(1) th:nth-child(1) {
            width: 48px;
            height: 42px;
        }

        #lvl {
            display: none;
        }

        .champion-border {
            width: 36px;
            height: 42px;
            overflow: hidden;
            position: static;
            display: inline-block;
        }

        .champion-border-half {
            width: 18px;
            height: 42px;
            overflow: hidden;
            position: static;
            display: inline-block;
        }

        .champion-border-third {
            width: 12px;
            height: 42px;
            overflow: hidden;
            position: static;
            display: inline-block;
        }

        .champion-border-container {
            position: absolute;
            width: 36px;
            height: 42px;
            overflow: hidden;
        }

        .champion-border-container-half {
            position: absolute;
            width: 18px;
            height: 42px;
            overflow: hidden;
        }

        .champion-border-container-third {
            position: absolute;
            width: 12px;
            height: 42px;
            overflow: hidden;
        }

        .champion-border-size {
            width: 80px;
            height: 312px;
            position: absolute;
        }

        .champion-border-size-half {
            width: 40px;
            height: 312px;
            position: absolute;
        }

        .champion-border-size-third {
            width: 27px;
            height: 312px;
            position: absolute;
        }

        .tier1 {
            margin: -42px 0 0 -18px;
        }
        .tier1-half {
            margin: -42px 0 0 -9px;
        }
        .tier1-third {
            margin: -42px 0 0 -6px;
        }
        .tier2 {
            margin: -42px 0 0 -54px;
        }
        .tier2-half {
            margin: -42px 0 0 -27px;
        }
        .tier2-third {
            margin: -42px 0 0 -18px;
        }
        .tier3 {
            margin: -126px 0 0 -18px;
        }
        .tier3-half {
            margin: -126px 0 0 -9px;
        }
        .tier3-third {
            margin: -126px 0 0 -6px;
        }
        .tier4 {
            margin: -126px 0 0 -54px;
        }
        .tier4-half {
            margin: -126px 0 0 -27px;
        }
        .tier4-third {
            margin: -126px 0 0 -18px;
        }
        .tier5 {
            margin: -210px 0 0 -18px;
        }
        .tier5-half {
            margin: -210px 0 0 -9px;
        }
        .tier5-third {
            margin: -210px 0 0 -6px;
        }
        .tier7 {
            margin: -210px 0 0 -54px;
        }
        .tier7-half {
            margin: -210px 0 0 -27px;
        }
        .tier7-third {
            margin: -210px 0 0 -18px;
        }

        th div:hover .details, td div:hover .details {
            visibility: visible;
        }

        th div .details, td div .details {
            visibility: hidden;
            z-index: 1;
            position: absolute;
            background-color: #333333;
            border: 2px #111111 solid;
            border-radius: 10px;
            padding: 12px;
            margin: 10px 0;
            max-width: 360px;
            font-weight: normal;
        }

        .details * {
            font-size: 12px;
            text-align: left;
            color: white;
        }

        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: rgb(29,29,31);
        }

        ::-webkit-scrollbar-thumb {
            background: rgb(61,61,63);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgb(93,93,95);
        }

        @media all and (max-width: 1100px) {
            body {
                height: 1200px;
                justify-content: flex-start;
                overflow: initial;
            }
            #navbar, .itemtable, .championtable {
                align-self: center;
            }
        }
    </style>
</head>
<body onload="init()">
<ul id="navbar">
    <li>
        <a href="tft_match_history.html" class="menuitem">Match History</a>
    </li>
</ul>
<!--<div id="credits">
    TFT Cheat Sheet by Lucube128
</div>-->
        <!-- thirdcell template
        <td><div class="champion-border-third"><img src="http://raw.communitydragon.org/latest/game/assets/ux/tftmobile/ingame/tftm_unitshop_cards_texture_atlas.png" class="champion-border-size-third tier1"><div class="thirdcell">
            <img src="https://raw.communitydragon.org/latest/game/assets/characters/tft3_zoe/hud/tft3_zoe_square.tft_set3.png"
                 class="thirdcellimg"/></div>
        </div><div class="champion-border-third"><img src="http://raw.communitydragon.org/latest/game/assets/ux/tftmobile/ingame/tftm_unitshop_cards_texture_atlas.png" class="champion-border-size-third tier2-third"><div class="thirdcell">
            <img src="https://raw.communitydragon.org/latest/game/assets/characters/tft3_ahri/hud/tft3_ahri_square.tft_set3.png"
                 class="thirdcellimg"/></div>
        </div><div class="champion-border-third"><img src="http://raw.communitydragon.org/latest/game/assets/ux/tftmobile/ingame/tftm_unitshop_cards_texture_atlas.png" class="champion-border-size-third tier3"><div class="thirdcell">
            <img src="https://raw.communitydragon.org/latest/game/assets/characters/tft3_syndra/hud/tft3_syndra_square.tft_set3.png"
                 class="thirdcellimg"/></div>
        </div><div class="details TFT3_Syndra"></div></td>
        -->
<script>
    let asdf = 1;
    let series = 0;
    const baseURL = "http://raw.communitydragon.org/latest/game/";
    const traitsArray = [["Cultist", "Divine", "Dusk", "Enlightened", "Elderwood", "Exile", "Fortune", "Moonlight", "Ninja", "Spirit", "Warlord", "The Boss", "Tormented"], // [0]: Origins
        ["Adept", "Assassin", "Brawler", "Dazzler", "Duelist", "Hunter", "Keeper", "Mage", "Mystic", "Shade", "Sharpshooter", "Vanguard", "Emperor"]]; // [1]: Classes
    const itemsArray = [0, 1, 2, 3, 4, 5, 6, 7, 9, 8];

    function init() {
        let file = "http://raw.communitydragon.org/latest/cdragon/tft/en_gb.json";
        let xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function () {
            if (this.readyState === 4 && this.status === 200) {
                enrich(JSON.parse(this.responseText));
            }
        };
        xhttp.open("GET", file, true);
        xhttp.send();
    }


    // returns file in string
    function enrich(text) {
        // get series number
        series = Object.keys(text.sets).length;
        text = removeOldDuplicates(text);

        buildItemTable();
        buildChampionTable(text.sets[series].traits);
        addChampionPositions(text.sets[series].champions);

        addItemIcons(text.items);
        addChampionIcons(text);
        addTraitIcons(text);
        addItemDescriptions(text.items);
        addTraitDescriptions(text);
        addChampionDescriptions(text);
        showContent();
    }

    // build table structure for items
    function buildItemTable() {
        let len = 10, fullItemID = 11, item = "item";
        let itemTable = document.createElement("table");
        let itemTBody = document.createElement("tbody");
        let itemTR = document.createElement("tr");
        let itemTH = document.createElement("th");
        let itemTD = document.createElement("td");
        let itemDiv1 = document.createElement("div");
        let itemDiv2 = document.createElement("div");
        let itemImg1 = document.createElement("img");
        let itemImg2 = document.createElement("img");
        itemTable.classList.add("itemtable");

        itemDiv1.appendChild(itemImg1);
        itemDiv2.appendChild(itemImg2);
        itemTH.appendChild(itemDiv1);
        itemTD.appendChild(itemDiv2);
        for (let i = 0; i < len; i++) {
            let baseTH = itemTH.cloneNode(true);
            baseTH.firstChild.classList.add(item + itemsArray[i]);
            itemTR.appendChild(baseTH);
        }
        itemTBody.appendChild(itemTR);

        for (let j = 1; j < len; j++) {
            let row = itemTR.cloneNode(false);
            let baseTH = itemTH.cloneNode(true);
            baseTH.firstChild.classList.add(item + itemsArray[j]);
            row.appendChild(baseTH);
            fullItemID = 10 + j;
            for (let i = 1; i < len; i++) {
                let x = itemsArray[Math.floor(fullItemID/10)];
                let y = itemsArray[fullItemID%10];
                if (x > y) {
                    x *= y;
                    y = x / y;
                    x /= y;
                }

                let fullTD = itemTD.cloneNode(true);
                fullTD.firstChild.classList.add(item + (x*10 + y));
                fullItemID++;
                if (i < j) {
                    fullItemID += 9;
                }
                row.appendChild(fullTD);
            }
            itemTBody.appendChild(row);
        }

        itemTable.appendChild(itemTBody);
        document.body.appendChild(itemTable);
    }

    // build table structure according to current Origins and Classes
    function buildChampionTable(traits) {
        let championTable = document.createElement("table");
        let championTBody = document.createElement("tbody");
        let championTR = document.createElement("tr");
        let traitTH = document.createElement("th");
        let championCorner = document.createElement("th");
        let championTD = document.createElement("td");
        let traitDiv = document.createElement("div");
        let traitImg = document.createElement("img");
        championTable.classList.add("championtable");

        championTR.appendChild(championCorner);
        championTBody.appendChild(championTR);

        traitDiv.appendChild(traitImg);
        traitTH.appendChild(traitDiv);
        for (let i = 0; i < traitsArray[0].length; i++) {
            let th = traitTH.cloneNode(true);
            th.firstChild.id = getApiNameByName(traits, traitsArray[0][i]);
            championTR.appendChild(th);
        }
        for (let i = 0; i < traitsArray[1].length; i++) {
            let tr = championTR.cloneNode(false);
            let th = traitTH.cloneNode(true);
            th.firstChild.id = getApiNameByName(traits, traitsArray[1][i]);
            tr.appendChild(th);

            for (let j = 0; j < traitsArray[0].length; j++) {
                let td = championTD.cloneNode(true);
                tr.appendChild(td);
            }
            championTBody.appendChild(tr);
        }

        championTable.appendChild(championTBody);
        document.body.appendChild(championTable);
    }

    // defines positions of champions in championtable
    function addChampionPositions(champions) {
        let championTable = document.getElementsByClassName("championtable")[0];
        let championDiv = document.createElement("div");

        for (let i = 0; i < champions.length; i++) {
            let championBorder = "champion-border";
            let cDiv = championDiv.cloneNode(true);
            let len = champions[i].traits.length, container = [], tPos = [];
            cDiv.classList.add(champions[i].apiName);


            // get cell position for champion
            if (len === 2) {
                for (let j = 0; j < len; j++) {
                    tPos[j] = traitsArray[j].indexOf(champions[i].traits[j]);
                }
                container[0] = championTable.firstChild.childNodes[tPos[1] + 1].childNodes[tPos[0] + 1];
            }
            else if (len === 3) {
                tPos[0] = traitsArray[0].indexOf(champions[i].traits[0]);
                tPos[1] = 0;
                tPos[2] = traitsArray[1].indexOf(champions[i].traits[2]);

                if (traitsArray[0].indexOf(champions[i].traits[1]) !== -1) {
                    tPos[1] = traitsArray[0].indexOf(champions[i].traits[1]);
                    container[0] = championTable.firstChild.childNodes[tPos[2] + 1].childNodes[tPos[0] + 1];
                    container[1] = championTable.firstChild.childNodes[tPos[2] + 1].childNodes[tPos[1] + 1];
                }
                else if (traitsArray[1].indexOf((champions[i].traits[1])) !== -1) {
                    tPos[1] = traitsArray[1].indexOf(champions[i].traits[1]);
                    container[0] = championTable.firstChild.childNodes[tPos[1] + 1].childNodes[tPos[0] + 1];
                    container[1] = championTable.firstChild.childNodes[tPos[2] + 1].childNodes[tPos[0] + 1];
                }
            }

            for (let j = 0; j < container.length; j++) {
                // for cells with multiple champions
                if (container[j].childNodes.length === 1) {
                    championBorder += "-half";
                } else if (container[j].childNodes.length === 2) {
                    championBorder += "-third";
                }
                for (let k = 0; k < container[j].childNodes.length; k++) {
                    container[j].childNodes[k].classList.remove("champion-border");
                    container[j].childNodes[k].classList.remove("champion-border" + "-half");
                    container[j].childNodes[k].classList.add(championBorder);
                }


                let cPos = cDiv.cloneNode(true);
                cPos.classList.add(championBorder);
                container[j].appendChild(cPos);
            }
        }
    }

    // add item icons according to prebuild table with ids
    function addItemIcons(items) {
        let len = items.length;
        for (let i = 0; i < len; i++) {
            let itemCells = document.getElementsByClassName("item" + items[i].id);
            for (let j = 0; j < itemCells.length; j++) {
                itemCells[j].firstChild.src = baseURL + items[i].icon.slice(0, -3).toLowerCase() + "png";
                itemCells[j].firstChild.alt = items[i].name;
            }
        }

        // item top left corner: tft_item_bag_questionmark.tft_set4.png
        let itemCells = document.getElementsByClassName("item0");
        itemCells[0].firstChild.src = baseURL + "assets/maps/particles/tft/tft_item_bag_questionmark.tft_set4." + "png";
        itemCells[0].firstChild.alt = "?";
    }

    // add cost borders on champions
    function addChampionIcons(text) {
        let len = text.sets[series].champions.length;

        for (let i = 0; i < len; i++) {
            putCostBorder(text.sets[series].champions[i]);
            putChampionIcon(text.sets[series].champions[i]);
        }
    }

    // add trait icons
    function addTraitIcons(text) {
        let len = text.sets[series].traits.length;

        for (let i = 0; i < len; i++) {
            putTraitIcon(text.sets[series].traits[i]);
        }
    }

    // put champion descriptions
    function addChampionDescriptions(text) {
        let len = text.sets[series].champions.length;

        for (let i = 0; i < len; i++) {
            descriptionAbilityCleanup(text.sets[series].champions[i].ability);
            putChampionDescription(text, text.sets[series].champions[i].apiName);
        }
    }

    // put trait descriptions
    function addTraitDescriptions(text) {
        let len = text.sets[series].traits.length;

        for (let i = 0; i < len; i++) {
            descriptionTraitCleanup(text.sets[series].traits[i]);
            putTraitDescription(text, text.sets[series].traits[i].apiName);
        }
    }

    // put item descriptions
    function addItemDescriptions(items) {
        let len = items.length;

        for (let i = 0; i < len; i++) {
            descriptionItemCleanup(items[i]);
            putItemDescription(items, items[i].id);
        }
    }

    // add cost borders
    function putCostBorder(text) {
        let numCells = document.getElementsByClassName(text.apiName).length;
        let championBorder = "champion-border";
        let borderImg = document.createElement("img");
        borderImg.src = "http://raw.communitydragon.org/latest/game/assets/ux/tftmobile/ingame/tftm_unitshop_cards_texture_atlas.png";
        borderImg.alt = "cost border sprite";

        for (let i = 0; i < numCells; i++) {
            let bI = borderImg.cloneNode(true);
            let cBC = document.createElement("div");
            let pEle = document.getElementsByClassName(text.apiName)[i];
            let parting = pEle.classList[1].slice(championBorder.length);
            cBC.classList.add(championBorder + "-container" + parting);
            bI.classList.add(championBorder + "-size" + parting);

            bI.classList.add("tier" + text.cost + parting);
            cBC.appendChild(bI);
            pEle.appendChild(cBC);
        }
    }

    // add champion icon
    function putChampionIcon(text) {
        // nexus and azirsoldier are not champions
        if (text.apiName === "TFT4_NPC_Nexus" || text.apiName === "TFT4_AzirSoldier") {
            return;
        }

        let numCells = document.getElementsByClassName(text.apiName).length;
        let championBorder = "champion-border";
        let championImg = document.createElement("img");
        championImg.src = getChampionImgLink(text);
        championImg.alt = text.name;

        for (let i = 0; i < numCells; i++) {
            let cI = championImg.cloneNode(true);
            let pEle = document.getElementsByClassName(text.apiName)[i];

            // for double/triple-cells
            if (pEle.classList[1].slice(championBorder.length) !== "") {
                let parting = pEle.classList[1].slice(championBorder.length + 1);
                let multDiv = document.createElement("div");
                multDiv.classList.add(parting + "cell");
                cI.classList.add(parting + "cellimg");

                multDiv.appendChild(cI);
                pEle.appendChild(multDiv);
            }
            // for single cells
            else {
                pEle.appendChild(cI);
            }
        }
    }

    function getChampionImgLink(text) {
        let endStr = text.icon.slice("ASSETS/UX/TFT/ChampionSplashes/".length, -3);
        let dotPos = endStr.indexOf(".");

        return (baseURL + "ASSETS/Characters/" + text.apiName + "/HUD/" + endStr.slice(0, dotPos) + "_square" + endStr.slice(dotPos) + "png").toLowerCase();
    }

    // replace trait icons
    function putTraitIcon(text) {
        document.getElementById(text.apiName).firstChild.src = baseURL + (text.icon.slice(0, -3).toLowerCase()) + "png";
        document.getElementById(text.apiName).firstChild.alt = text.name;
    }

    // add description text to champion
    function putChampionDescription(text, championApiName) {
        let toolTipDiv = document.createElement("div");
        let index = getIndexByApiNameC(text, championApiName);
        let toolTip = "<p><b>" + text.sets[series].champions[index].name + "</b></p><br>";
        toolTip += "<p>" + text.sets[series].champions[index].ability.desc + "</p>";
        toolTipDiv.innerHTML = toolTip;
        toolTipDiv.classList.add("details");

        for (let i = 0; i < document.getElementsByClassName(championApiName).length; i++) {
            let tTD = toolTipDiv.cloneNode(true);
            document.getElementsByClassName(championApiName)[i].appendChild(tTD);
        }
    }

    // add description text to trait
    function putTraitDescription(text, traitApiName) {
        let index = getIndexByApiName(text, traitApiName);
        let toolTip = "<p><b>" + text.sets[series].traits[index].name + "</b></p><br>";
        toolTip += "<p>" + text.sets[series].traits[index].desc + "</p>";
        let traitDesc = document.createElement("div");
        traitDesc.classList.add("details");
        traitDesc.innerHTML = toolTip;

        document.getElementById(traitApiName).appendChild(traitDesc);
    }

    // add description text to item
    function putItemDescription(items, itemId) {
        if (itemId === 100) { // do not add tooltip for top left item icon
            return;
        }
        let index = getIndexById(items, itemId);

        // stupid bug fix
        if (items[index].name === "Duelist's Zeal") {
            if (asdf === 0) {
                return;
            } else {
                asdf = 0;
            }
        }

        let toolTip = "<p><b>" + items[index].name + "</b></p><br>";
        toolTip += "<p>" + items[index].desc + "</p>";
        let details = document.createElement("div");
        details.classList.add("details");
        details.innerHTML += toolTip;

        for (let i = 0; i < document.getElementsByClassName("item" + itemId).length; i++) {
            let dT = details.cloneNode(true);
            document.getElementsByClassName("item" + itemId)[i].appendChild(dT);
        }
    }

    // get trait array index by apiName C
    function getIndexByApiNameC(jsontext, apiName) {
        let len = jsontext.sets[series].champions.length;
        for (let i = 0; i < len; i++) {
            if (jsontext.sets[series].champions[i].apiName === apiName) {
                return i;
            }
        }

        return -1;
    }

    // get trait array index by apiName
    function getIndexByApiName(jsontext, apiName) {
        let len = jsontext.sets[series].traits.length;
        for (let i = 0; i < len; i++) {
            if (jsontext.sets[series].traits[i].apiName === apiName) {
                return i;
            }
        }

        return -1;
    }

    // get item array index by Id
    function getIndexById(items, id) {
        let len = items.length;
        for (let i = 0; i < len; i++) {
            if (items[i].id === id) {
                return i;
            }
        }

        return -1;
    }

    // get apiName by trait name
    function getApiNameByName (traits, name) {
        for (let i = 0; i < traits.length; i++) {
            if (traits[i].name === name) {
                return traits[i].apiName;
            }
        }
        return "";
    }

    // bugfix due to duplicate ids in json in items
    function removeOldDuplicates(jsontext) {
        let len = jsontext.items.length, tmp;
        // remove items via invalid ids
        for (let i = 0; i < len; i++) {
            if (jsontext.items[i].id < 0 || jsontext.items[i].id > 100) {
                jsontext.items.splice(i--, 1);
                len--;
            }
        }

        // remove items via item name
        let rmStr = ["Youmuu's Ghostblade", "Blade of the Ruined King", "Inferno's Cinder", "Mages Cap", "Warden's Mail", "Talisman of Light", "Frozen Mallet", "Berserker's Axe",
            "Infiltrator's Talons", "Battlecast Plating", "Star Guardian's Charm", "Rebel Medal", "Celestial Orb", "Protector's Chestguard", "Dark Star's Heart"];// for items that are used from previous tft-sets

        for (let i = 0; i < len; i++) {
            if (jsontext.items[i].id === 89 && jsontext.items[i].name === rmStr[0]) {
                tmp = jsontext.items[i];
            }
        }

        for (let i = 0; i < len; i++) {
            if (rmStr.includes(jsontext.items[i].name)) {
                jsontext.items.splice(i--, 1);
                len--;
            }
        }

        jsontext.items.push(tmp);
        return jsontext;
    }

    function descriptionItemCleanup(item) {
        for (let x = 0, y = 0; (x = item.desc.indexOf("@", x)) !== -1; ) {
            y = item.desc.indexOf("@", ++x) + 1;

            item.desc = replaceItemKeys(item, item.desc.slice(x, y - 1));
        }
    }

    function replaceItemKeys(item, strKey) {
        let mappedKey = strKey;
        // key is not in text form but rather {ffffffff}
        if (item.effects[strKey] === undefined) {
            // switch key for value in desc
            let keyValuePairs = {
                BonusAP: "{d49caf5d}",
                BonusCritDmgPerCritAbove100: "{45c7ed6b}",
                ChanceOnHitToSilence: "{2275757b}",
                CostIncrease: "{a861afa0}",
                BanishDuration: "{510fdb6a}",
                HexRange: "{9b1e8f37}",
                MRShred: "{fe079f34}",
                ManaRatio: "{df6f64b9}",
                DamageReflect: "{6688a0d5}",
                ArmorPerEnemy: "{7ba8c0e3}",
                MRPerEnemy: "{7c694b41}",
                "1StarAoEDamage": "{1ee760be}",
                "2StarAoEDamage": "{6688a0d5}",
                "3StarAoEDamage": "{156febb8}",
                ICD: "{73e0fa13}",
                FreezeDuration: "{aaa03dde}",
                ChanceToSpellSteal: "{0cc88d45}",
                DodgeChancePercent: "{0e4779e5}",
                SmallBonusPct: "{deada01e}",
                HealthThreshold: "{28b26e8a}",
                LargeBonusPct: "{b8ae7546}",
                AttackSpeedPercent: "{a8ca7859}",
                BurnPercent: "{57706a69}",
                BurnDuration: "{97e52ce8}",
                GrievousWoundsPercent: "{2161bfa2}",
                CritChancePerStack: "{cb57edb0}", // id: 93 and 94
                TraitMultiplier: "{ae49cc70}",
                ChanceOnHitToShrink: "{a56e0a21}",
                StasisDuration: "{c425872e}",
                ManaRestore: "{03494ad0}",
                ADPerStack: "{f1d43b01}",
                StartingStacks: "{ad68ce80}",
                DamageIncreasePercent: "{d50b4559}",
                StackCap: "{9396f00d}",
                BonusResistsAtStackCap: "{b55019fa}",
                MultiplierForDamage: "{276ba2c8}",
                DodgeChance: "{c4b5579c}",
                Lifesteal: "LifeSteal",
                "1StarZombieHealth": "{37b0144c}",
                "2StarZombieHealth": "{86646c65}",
                "3StarZombieHealth": "{f6edd39e}",
                FlatManaRestore: "{4b9a3b61}",
                ExtraBounces: "{93d13af6}", // check value id:71
                "1StarShieldValue": "{6fb9af6a}",
                "2StarShieldValue": "{0d46330d}",
                "3StarShieldValue": "{829e6cec}",
                AttackRange: "{c270990a}",
                ArmorReductionPercent: "{5079c7a2}",
                ArmorBreakDuration: "{cc9fefa7}",
                CritDamageAmp: "{353ede36}",
                MaxArmySizeIncrease: "{ec9a04d1}",
                SpellShieldDuration: "{a2b76524}",
                TooltipDisplayHealth: "{452fd23c}",
                "1StarBounces": "{440f813d}", // check values id:100
                "2StarBounces": "{12a15e9e}", // check values id:100
                "3StarBounces": "{79e2ec7b}", // check values id:100
                OmniVamp: "{ad16f688}",
                HPPerRound: "{1bb18b94}",
                BonusDamageVsShieldOrCC: "{13206100}"
            };
            mappedKey = keyValuePairs[strKey];
        }

        return item.desc.replace("@" + strKey + "@", item.effects[mappedKey]);
    }

    /*
     * Finds placeholder <> and @@ strings and replaces them with their dynamic values.
     * @Para: Object of only a trait atm
     */
    function descriptionTraitCleanup(trait) {
        let effectLen = trait.effects.length;

        // Removes (@MinUnits@) at the beginning of Moonlight description
        if (trait.name === "Moonlight") {
            trait.desc = trait.desc.slice(13);
        }

        // removes <br> elements at the end
        let br = "<br>";
        while (trait.desc.slice((-1) * br.length) === br) {
            trait.desc = trait.desc.slice(0, trait.desc.length - br.length);
        }

        // expandRows
        let expandStart = "<expandRow>", expandEnd = "</expandRow>";
        let expandStartPos = trait.desc.search(expandStart),
            expandEndPos = trait.desc.search(expandEnd) + expandEnd.length;
        let expandString = trait.desc.slice(expandStartPos, expandEndPos);
        trait.desc += expandString.repeat(effectLen - 1);


        /* replace @MinUnits@ with values
         * replace <expandRow> with ""
         * replace </expandRow> with <br>
         */
        let minUnits = "@MinUnits@";
        for (let i = 0; i < effectLen; i++) {
            trait.desc = trait.desc.replace(minUnits, trait.effects[i].minUnits);
            trait.desc = trait.desc.replace(expandStart, "");
            trait.desc = trait.desc.replace(expandEnd, br);
        }

        // try replacing other keys
        for (let x = 0, y = 0, keys = {}; (x = trait.desc.indexOf("@", x)) !== -1; ) {
            y = trait.desc.indexOf("@", ++x) + 1;

            trait.desc = replaceTraitKeys(trait, trait.desc.slice(x, y - 1), keys);
        }
    }

    function replaceTraitKeys(trait, strKey, keys) {
        let mappedKey;

        if (keys[strKey] === undefined) {
            keys[strKey] = 0;

            // exceptions of Dusk, Exile
            if (strKey === "DuskSpellPower" || strKey === "LifeSteal") {
                keys[strKey]++;
            }
        } else {
            keys[strKey]++;

            // exceptions of Dusk
            if (strKey === "TeamSpellPower" && keys[strKey] === 1) {
                keys[strKey]++;
            }
        }

        mappedKey = strKey;
        // key is not in text form but rather {ffffffff}
        if (trait.effects[keys[strKey]].variables[strKey] === undefined) {
            // switch key for value in desc
            let keyValuePairs = {
                NumAttacksToProc: "{ab28c2e5}",
                HealthThreshold: "{28b26e8a}",
                DamageReductionPercent: "{5064373e}",
                BonusTrueDamagePercent: "{db141d0a}",
                AttackSpeedSlowDuration: "{948540e5}",
                HealPercent: "{a8ca7859}",
                AttackSpeedPercent: "{e0882668}",
                ManaAmp: "{5d972a6c}",
                CritAmpPercent: "{268f634e}",
                CritChanceAmpPercent: "{9f2eb1e2}",
                ADValue: "{5eb5fde9}",
                APValue: "{fa127f0d}",
                VictoryPercent: "{4d63b2aa}",
                MaxCombats: "{8f2e74ba}",
                InitialHealth: "{14853b15}",
                InitialSP: "{0d6fd940}",
                AttackSpeedManaCostPercent: "{dbd3e597}",
                TeamSpellPower: "{aa5d5de7}",
                DuskSpellPower: "{845f7bf3}",
                BonusResists: "{d089365f}",
                BonusADSP: "{d53b93b2}",
                SPPercent: "{1163964f}",
                RoundsToTransform: "{5ef02437}",
                DamageAmp: "{4c67d4fe}",
                ShotFrequency: "{428a4c11}",
                MaxBounces: "{76740106}",
                PercentDamageReduction: "{bdd452e8}",
                CultistHealthPercentTaken: "{a640a6f5}",
                KeeperBonus: "{995b1992}",
                ShieldAmount: "{40ee74ec}",
                NumberOfChampions: "{a6d1e24b}",
                NumberOfAttacks: "{0140347e}"
            };
            mappedKey = keyValuePairs[strKey];
        }

        return trait.desc.replace("@" + strKey + "@", trait.effects[keys[strKey]].variables[mappedKey]);
    }

    function descriptionAbilityCleanup(ability) {
        let mod = "Modified";
        if (ability.desc === null) {
            return;
        }

        for (let x = 0, y = 0, keyStr, mappedStr, pos; (x = ability.desc.indexOf("@", x)) !== -1; ) {
            pos = -1;
            y = ability.desc.indexOf("@", ++x) + 1;

            keyStr = ability.desc.slice(x, y - 1);
            if (keyStr.search(mod) === 0) {
                mappedStr = keyStr.slice(mod.length);
            }
            else {
                mappedStr = keyStr;
            }

            let lenVariables = ability.variables.length;
            for (let c = 0; pos === -1 && c < 13; c++) {
                for (let i = 0; i < lenVariables; i++) {
                    if (ability.variables[i].name === mappedStr) {
                        pos = i;
                        break;
                    }
                }

                /* values that don't work: Talon: @TooltipBonusDamage@ %i:scaleAD%
                 *                         Yasuo: @TooltipDamage@
                 *                      Xin Zhao: @TooltipDamage@
                 *                          Ashe: @ModifiedADDamage@
                 *                          Jhin: @TooltipDamage@
                 *                        Wukong: @TooltipDamage@
                 *                         Garen: @ModifiedDamage@
                 */
                let keyFallback = [{
                    ModifiedShield: "ShieldAmount",
                    ModifiedAS: "AttackSpeed",
                    ModifiedADDamage: ["PercentADPerArrow", "NumArrows"],
                    ModifiedDamage: "WallDamage",
                    ModifiedCritDamage: "CritMultiplier",
                    ExecuteThreshholdPercent: "CritThreshold",
                    "MagicDamageReduction*100": "MagicDamageReduction",
                    ModifiedPercent: "PercentOfAD",
                    TooltipDamage: ["ADFromAttackSpeed", "PercentOfAD"],
                    "PercentPerHex*100": "PercentPerHex",
                    "DamageAmp*100": "DamageAmp",
                    ModifiedDR: "DamageReduction",
                    "PercentOfAD*100": "PercentOfAD",
                    TooltipBonusDamage: [""],
                    "DamageReduction*100": "DamageReduction",
                    "ADSteal*100": "ADSteal",
                    HealthAmountCalc: "HealthAmount",
                    "ArmorReduction*100": "ArmorReduction",
                    DamageCalc: "Damage",
                    "PercentRestored*100": "PercentRestored",
                    ModifiedHeal: "BaseHeal",
                    "BaseDR*100": "BaseDR"
                }, {
                    ModifiedShield: "ShieldValue",
                    ModifiedDamage: "OrbDamage",
                    TooltipDamage: [""],
                    "DamageAmp*100": "DamageAmp", // duplicate pair
                    ModifiedAS: "AttackSpeed" // duplicate pair
                }, {
                    ModifiedDamage: ["ETotalTicks", "DamagePerTick"],
                    ModifiedShield: "Shield Amount", // duplicate pair
                    TooltipDamage: [""],
                    ModifiedAS: "AttackSpeed" // duplicate pair
                }, {
                    ModifiedDamage: "RocketDamage",
                    ModifiedShield: "Shield Amount", // duplicate pair
                    TooltipDamage: [""],
                    ModifiedAS: "AttackSpeedPercent"
                }, {
                    ModifiedDamage: "PercentHealthDamage"
                }, {
                    ModifiedDamage: "BaseDamage"
                }, {
                    ModifiedDamage: "BaseDamage" // duplicate pair
                }, {
                    ModifiedDamage: "TotalDamage"
                }, {
                    ModifiedDamage: "BaseDamage" // duplicate pair
                }, {
                    ModifiedDamage: "BonusDamage"
                }, {
                    ModifiedDamage: "ADPercent"
                }, {
                    ModifiedDamage: "TotalDamage" // duplicate pair
                }, {
                    ModifiedDamage: "BaseDamage" // duplicate pair
                }];
                if (keyFallback[c][keyStr] !== undefined) {
                    mappedStr = keyFallback[c][keyStr];
                }
            }
            if (pos === -1) {
                continue;
            }

            let valuesStr, value1 = Math.round(ability.variables[pos].value[1] * 100) / 100,
                value2 = Math.round(ability.variables[pos].value[2] * 100) / 100,
                value3 = Math.round(ability.variables[pos].value[3] * 100) / 100,
                value4 = Math.round(ability.variables[pos].value[4] * 100) / 100;
            if (keyStr.search("/*100") !== -1) {
                value1 *= 100;
                value2 *= 100;
                value3 *= 100;
                value4 *= 100;
            }
            // only show one value if they are the same
            if (value1 === value2 &&
                value2 === value3) {
                valuesStr = value1;
            }
            else {
                valuesStr = value1 + "/" +
                    value2 + "/" +
                    value3;
            }
            // add fourth value for Moonlight champions
            if ((ability.name === "Pale Cascade" || ability.name === "Chain Lash" || ability.name === "1000 Daggers" || ability.name === "Sentry Turret")
                && valuesStr !== value4) {
                valuesStr += "/" + value4;
            }

            ability.desc = ability.desc.replace("@" + keyStr + "@", valuesStr);
        }
    }

    function showContent() {
        let len = document.body.childNodes.length;
        for (let i = 0; i < len; i++) {
            document.body.childNodes[i].style = "visibility: visible";
        }
    }
</script>
</body>
</html>